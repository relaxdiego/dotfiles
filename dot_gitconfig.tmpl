; vim: set ft=gitconfig:

{{ if not .shared_machine -}}
[user]
    name = {{ .fullname }}
    email = {{ .email }}
    signingkey = {{ .gpg_fingerprint }}

; The file below can contain conditional includes that customizes the [user]
; stanza according to the current path. For example, it might contain:
;
;   [includeIf "gitdir:~/src/github.com/company-name/"]
;      path = ~/.gitconfig-company-name
;
; The above means: if the current repo is a child of ~/src/../company-name,
; include ~/.gitconfig-company-name. In turn, the file ~/.gitconfig-company-name
; might contain:
;
;   [user]
;       email = myemailaddress@company-name.com
;       signingKey = <gpg-signing-key-associated-with-company-email>
;
; For more info on what the file can contain, see https://git-scm.com/docs/git-config
;
; NOTE: The file below is ensured present by run_000_ensure_files.sh.tmpl
[include]
    path = ~/.gitconfig-custom

[github]
    user = {{ .github_username }}

[commit]
    gpgsign = true
    template = ~/.git-commit-template.txt

[gpg]
{{- if eq .chezmoi.os "linux" }}
    program = gpg2
{{- else if eq .chezmoi.os "darwin" }}
    program = gpg
{{- end }}
{{- end }}

[color]
    ui = auto
    branch = auto
    diff = auto
    status = auto

[color "branch"]
    current = green reverse
    local = green
    remote = red

[color "diff"]
    meta = yellow
    frag = magenta
    old = red
    new = green

[color "status"]
    added = yellow
    changed = green
    untracked = cyan

[alias]
    # Aliases used by other aliases below
    # From https://github.com/fcsonline/dotfiles/blob/7211d48fb06eec96a415063cf07df240096bc9bf/git/gitconfig#L32-L33
    recent = !git for-each-ref --sort=-committerdate --format='%(refname:short)' refs/heads/ | head -n 100
    fixit  = "!f() { git commit --fixup=$1; GIT_SEQUENCE_EDITOR=: git rebase -i --autosquash $1~1; }; f"

    # From https://github.com/fcsonline/dotfiles/blob/7211d48fb06eec96a415063cf07df240096bc9bf/git/gitconfig#L32-L33
    checkout = !BRANCH=`git recent | fzf` && git checkout ${BRANCH}

    # From https://github.com/fcsonline/dotfiles/blob/7211d48fb06eec96a415063cf07df240096bc9bf/git/gitconfig#L32-L33
    fixup = !HASH=`git log --pretty=oneline | head -n 100 | fzf` && git fixit `echo ${HASH} | awk '{ print $1 }'`

    fa  = fetch --all
    far = fetch --all --recurse-submodules

    unstage = reset HEAD --
    undo    = reset --soft HEAD^  # Undo the last commit and put it back in the index
    rh      = reset --hard        # Clear all changes in workspace and index

    tree = log --graph --oneline --decorate --color --format='%C(auto)%h %C(green)%as%C(auto) %C("#666666")%an%C(auto)%d %s%C(reset)'
    t    = tree
    ta   = t --all
    ti   = t --format='%C(auto)%h %C(green)%ai%C(auto)%d %s%C(reset)'  # Tree, using ISO8601 format
    tai  = ti --all
    tr   = t --format='%C(auto)%h %C(green)%ar%C(auto)%d %s%C(reset)'  # Tree, using relative times
    tar  = tr --all

    # Branch stats
    stats = log --decorate --color --format='%n%C(auto)%h %C(green)%ai%C(auto) %C("#666666")%an%C(auto)%d %s%C(reset)' --compact-summary
    s     = stats
    sa    = stats --all

    # fzf goodness! From https://medium.com/hackernoon/be-125-more-efficient-with-git-60556a1ce971
    fuzzy-checkout = !BRANCH=`git recent | fzf` && git checkout ${BRANCH}
    fuzzy-add      = !FILES=`git status -s | awk '{ print $2 }' | fzf -x -m` && git add --all ${FILES}
    fuzzy-fix      = !HASH=`git log --pretty=oneline | head -n 100 | fzf` && git fixit `echo ${HASH} | awk '{ print $1 }'`
    fuzzy-show     = !HASH=`git log --pretty=oneline | head -n 100 | fzf` && git show `echo ${HASH} | awk '{ print $1 }'`
    fuzzy-log      = !HASH=`git log --pretty=oneline | head -n 100 | fzf` && echo ${HASH} | awk '{ print $1 }' | xargs echo -n | pbcopy
    fuzzy-rebase   = !HASH=`git log --pretty=oneline | head -n 100 | fzf` && git rebase -i `echo ${HASH} | awk '{ print $1 }'`^
    fuzzy-vim      = !FILES=`git status -s | awk '{ print $2 }' | fzf -x -m` && vim -O ${FILES}
    fuzzy-grep     = !sh -c 'FILES=`git grep -l -A 0 -B 0 $1 $2 | fzf -x -m` && vim -O `echo ${FILES} | cut -d':' -f1 | xargs`' -
    fuzzy-vimlog   = !HASH=`git log --pretty=oneline | head -n 50 | fzf` && HASHZ=`echo ${HASH} | awk '{ print $1 }'` && FILES=`git show --diff-filter=d --pretty='format:' --name-only $HASHZ | grep -v -e '^$' | fzf -x -m` && vim -O ${FILES}
    fuzzy-reset    = !HASH=`git log --pretty=oneline | head -n 50 | fzf` && git reset --soft `echo ${HASH} | awk '{ print $1 }'`^

[apply]
    whitespace = strip

[pager]
    color = true

[status]
    color = true

[core]
    whitespace = trailing-space,space-before-tab
    excludesfile = ~/.gitignore_global
    editor = vim

[filter "media"]
    required = true
    clean = git media clean %f
    smudge = git media smudge %f

[push]
    default = current

[filter "lfs"]
	clean = git-lfs clean -- %f
	smudge = git-lfs smudge -- %f
	process = git-lfs filter-process
	required = true

[init]
    templatedir = ~/.git-template
    defaultBranch = main

[user]
	useConfigOnly = true
